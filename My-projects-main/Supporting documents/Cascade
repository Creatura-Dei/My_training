Понимание каскадов

ТРИ ФАКТОРА в порядке важности:

        1) Порядок следования

Если у меня несколько правил, которые имеют одинаковую важность, то превалирует правило, которое идёт последним в CSS. 


        2) Специфичность

Порядок следования правил имеет значение, и бывает так, что правило появляется позже в таблице стилей, но применяется более ранее, конфликтующее правило. Это связанно с тем, что раннее правило имеет более высокую специфичность.

Как мы знаем, селектор элемента имеет низкую специфичность, поэтому мы зачастую ставим правило общее на все абзацы, а классами добавляем тонкости.

Степень специфичности, которой обладает селектор, измеряется с использованием четырёх различных значений (или компонентов), которые можно представить как тысячи, сотни, десятки, единицы - четыре однозначные цифры в 4х стобцах.

ПРАВИЛА:

    1) ТЫСЯЧИ: 
            Поставьте единицу в эту колонку, если объявление стиля находится внутри атрибута style (встроенные стили). Такие объявления не имеют селектров, поэтому их специфичность всегда просто 1000.


    2) СОТНИ:
            Поставьте единицу в эту колонку за каждый селектор ID, содержащийся в общем селекторе.


    3) ДЕСЯТКИ:
            поставьте единицу в эту колонку за каждый селектор класса, селектор атриута или псевдокласс, содердащийся в общем селекторе.

    
    4) ЕДИНИЦЫ: 
            поставьте общее число единиц в эту колонку за каждый селектор элемента или псевдоэлемент, содержащийся в общем селеторе.


!Примечание
универсальный селектор, комбинаторы и псевдокласс отрицания (:not) НЕ ВЛИЯЮТ на специфичность.







3) Важность (!important):

        Есть специальный элемент CSS, который можно использовать для отмены всех вышеперечисленных вычислений. Он используется, чтобы сделать конкретное свойство и значение самым специфичными, таким образом переопределяя нормальные правила каскада.

#winning {
        background-color: red;
        border: 1px solid black;}

.better {
        background-color: gray;
        border: none !important;
}

p {
        background-color: blue;
        color: white;
        padding: 5px;
}

        <p class="better">This is a paragraph.</p>
        <p class="better" id="winning">One selector to rule them all!</p>

        В итоге применится border none - так как стоит импортант, но лучше его вообще не юзать.

===============================================

            СПЕЦИФИЧНОСТЬ

селектор класса имеет намного больший приоритет, нежели селектор элемента. Даже если элемента в каскаде ниже, чем класс.


Наследование
Некоторые значения свойств CSS, установленные для родительских элементов наследуются их дочерними элементами, а некоторые нет.
Типа если на элементе свойство, то оно распространяется на все, что находятся внутри него. Пока ты не применишь к ним персональные свойства.



КОНТРОЛЬ НАСЛЕДОВАНИЯ 
CSS предоставляет четыре специальных универсальных значения свойства для контроля наследования. 

        inherit
    Устанавливает значения свойства, применённого к элементу, таким же, как у его родительского элемента. Фактически, это "включает наследования" 


        initial
    Устанавливает значения свойства, применённого к выбранному элементу, равным initial value этого свойства (в соответствии с настройками браузера по умолчанию. Если в таблице браузера отстутствует)

        unset
    Возвращает свойство его единственное значение, что значит, что если свойства наследуется естественным образом, оно действует как inherit, Иначе оно действует как initial.


<div class="wrapper">
  <p class="one">Snake<p>
  <p class="two">Lizard<p>
  <p class="three">Alligator</p>
  <p>Komodo Dragon</p>
</div>

.wrapper { color: orange; }
.wrapper p { color: purple; }
p.one { color: inherit; }
p.two { color: initial; }
p.three { color: unset; }

Есть один трюк с unset 
Его можно сочетать с сокращением all, которое автоматически влияет на все свойства селектора. Например: применит код применит unset ко всем свойствам выбранных элементов p:

article p {
    all: unset;
}
===========================================
Существует три типа каскадных источников:

1) таблицы стилей пользовательского агента
2) пользовательские таблицы стилей
3) авторские таблицы стилей. 

        Браузер сортирует каждое объявление по шести сегментам происхождения по происхождению и важности.
        Существует восемь уровней приоритета: шесть исходных сегментов, свойства, которые переходят, и свойства, которые анимируются. Порядок приоритета идет от обычных стилей пользовательского агента, которые которые имеют самый низкий приоритет, к стилям в применяемых в данный момент анимациях, к важным стилям пользовательского агента, а затем перемещаемые стили, которые имеют наивысший приоритет:


1. user-agent normal styles
2. user normal styles
3. author normal styles
4. styles being animated
5. author important styles
6. user important styles
7. user-agent important styles
8. styles being transitioned


        «user-agent» — это браузер. 
        «user» — это посетитель сайта. 
        "author" - это вы, разработчик. 
        Стили, объявленные непосредственно в элементе с помощью элемента <style>, являются авторскими стилями.

        Не считая стилей анимации и перехода, обычные стили пользовательского агента имеют самый низкий приоритет; user-agent важные стили самые высокие.


Каскадные слои это новая CSS фича, которая позволяет разработчикам получать больший контроль над написанием CSS в больших проектах. По словам автора спецификации Miriam Suzanne:

Каскадные слои позволят авторам управлять своей внутренней каскадной логикой, не полагаясь полностью на эвристику специфичности или исходный порядок.

Давайте применим каскадные слои для предыдущего примера.

Для начала надо обозначит слой. Чтобы это сделать, мы напишем @layer с именем components. Внутри этого слоя нужно определить стили кнопки:


        @layer components { 
        .button {
                color: #fff;
                background-color: #030;
        }
      }

        Дальше добавляем слой для вариаций:

        @layer variations {
                .button--ghost {
                        background-color: #fff;
                        border: 2px solid #e0e0e0;
                }
        }

Слои аналогично слоям ФШ: что определено последним в CSS - будет первым в списке слоёв визуально. То есть тут variations определён последним, поэтому он будет иметь более высокий приоритет, чем слой components.

Также есть другой способ организации того, какой слой переопределяет другой, путём одновременного определения слоёв.

        @layer components (это типа 2), variations(это 1);



Вернёмся к нашему примеру. Основная проблема была в том, что нам нужно было создать новую вариацию кнопки, поместив её в место, где вариация бы имела меньшую специфичность (до .button). С каскадными слоями мы можем добавить этот кусок в слой variations.



        @layer components, variations;

        @layer components {
          .button { 
                color: #fff;
                background-color: #d73a7c;
            }
          }



        @layer variations {
        .button--ghost {
                background-color: transparent;
                color: #474747;
                border: 2px solid #e0e0e0;
        }

        .button--facebook {
        background-color: var(--brand-fb);
        }
        }


Однако мы можем поменять последовательность слоёв в перечислении правил, и тогда они поменяются местами, хотя сами слои переписывать на новые места переносить не пришлось.


        ЕСЛИ МЫ напишем слой с таким же названием (но там внутри например другое условие) ТО ТОГДА браузер соединит эти слои и накинет друг под другом, ничего не меняя в положении, то есть если ты через 100 строчек кода написал такой же - он возьмёт свойства и напишет в конец первого.



Также существует вложенность внутри слоёв: 


@layer base, elements, objects, components, pages, themes;

@layer themes {
    @layer custom, default;

    @layer default {
        :root {
            --color-primary: #1877f2;
        }
    }

    @layer custom {
        :root {
            --color-primary: #d73a7c;
        }
    }
}