<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>17</title>
</head>
<body>
    
    ОБЪЕКТЫ

7 типов данных называются примитивными, так как содержат только одно значение (строка или что-то другое)


Объекты же используются для хранения коллекций различных значений и более сложных сущностей. 


Объект может быть создан с помощью фигурных скобок {...} с необязательным списком свойств. 


СВОЙСТВО - это пара "ключ: значение", где ключ - это строка (также называемая "именем свойства"), а значение может быть чем угодно. 

Что-то вроде объекта в виде ящика с подписанными папками.
Каждый элемент данных хранится в своей папке, на которой написан ключ. По ключу папку легко найти, удалить или добавить в неё что-либо. 

Пустой объект ("пустой ящик") можно создать, используя один из двух вариантов синтаксиса:

    let user = new Object(); // синтаксис "конструктор объекта"
    let user = {}; // синтаксис "литерал объекта"

    Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.

Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки


+ желательно добавлять висячую запятую в конце

+ Квадратные скобки
Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
        let user = {};

        // присваивание значения свойству
        user["likes birds"] = true;

        // получение значения свойства
        alert(user["likes birds"]); // true

        // удаление свойства
        delete user["likes birds"];




Объект, объявленный как константа, может быть изменён

        const user = {
            name: "John"
        };
        
        user.name = "Pete"; // (*)
        
        alert(user.name); // Pete




Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:   


        let user = {
        name: "John",
        age: 30
        };

        let key = prompt("Что вы хотите узнать о пользователе?", "name");

        // доступ к свойству через переменную
        alert( user[key] ); // John (если ввели "name")



Запись «через точку» такого не позволяет:

        let user = {
          name: "John",
          age: 30
        };
        
        let key = "name";
        alert( user.key ); // undefined
_______________________________________________________________________





Вычисляемые свойства 

Также можно использовать квадратные скобки в литеральной нотации для создания ВЫЧИСЛЯЕМОГО СВОЙСТВА.

        let fruit = prompt('Какой фрукт купить?', "apple");

        let bag = {
            [fruit]: 5,
        };

        alert( bag.apple ); // 5. если fruit="apple"
 


По сути, пример выше работает так же, как и следующий пример:

        let fruit = prompt("Какой фрукт купить?", "apple");
        let bag = {};

        // имя свойства будет взято из переменной fruit
        bag[fruit] = 5;

_______________________________________________________________________


СВОЙСТВА ИЗ ПЕРЕМЕННОЙ

Часто необходимо использовать существующие переменные как значения для свойств с тем же именем. 

        function makeUser(name, age) {
          return {
            name: name; // или же просто name,
            age: age; // или же age, 
          };
        }

        let user = makeUser("John", 30);

        alert(user.name); // John

_______________________________________________________________________



ОГРАНИЧЕНИЯ НА ИМЕНА СВОЙСТВ


Имя переменной не может совпадать с зарезервированными словами, такими как "for" "let" "return"
НО ДЛЯ СВОЙСТВ ОБЪЕКТА такого ограничения НЕТ

        let obj = {
            for: 1,
            let: 2,
            return: 3,
        };

        alert( obj.for + obj.let + obj.return ); // 6


_______________________________________________________________________



Проверка существования свойства, оператор «in»


При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:

        let user = {};

        alert( user.noSuchProperty === undefined ); //true означает "свойства нет"



ТАКЖЕ существует специальный оператор "in" для проверки существования свойства в объекте. 

        синтаксис: "key" in object 

        пример: 

                let user = {
                    name: John, 
                    age: 30,
                };

                alert( "age" in user ); //true, user.age существует
                alert( "nature" in user ); //false, user.nature не существует 

!!!! 
|
| Слева от оператора in должно быть имя свойства. Обычно это строка в 
| кавычках
|
| Если мы опускаем кавычки, это значит, что мы указываем переменную, в 
| которой находится имя свойства.
|
!!!

_______________________________________________________________________



Цикл  "for..in"
        

Для перебора всех свойств объекта используется этот цикл, он отличается от обычного for(;;)


    Cинтаксис: 
        
           for (key in object) {
                // Тело цикла выполняется для каждого свойства объекта 
           }

        
    Пример (выводит все свойства объекта user):

        let user = {
                name: "John",
                age: 30,
                isAdmin: true, 
        };

        for (let key in user) {
                // Ключи
                alert( key ); // name, age, isAdmin
                // Значения ключей
                alert( user[key] ); //John, 30, true
        }

Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, как, например, let key здесь.

Кроме того, мы могли бы использовать другое имя переменной. Например, часто используется вариант "for (let prop in obj)"

_______________________________________________________________________



УПОРЯДОЧЕНИЕ СВОЙСТВ ОБЪЕКТА



Свойства упорядочены особым образом: 
                Свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. 


    Пример - объект с телефонными кодами

        let codes = {
                "49": "Германия",
                "41": "Швейцария",
                "44": "Великобритания",
                // ..,
                "1": "США",
        };

        for (let code in codes) {
                alert(code); // 1, 41, 44, 49 
        }


Если мы запустим код, мы увидим совершенно другую картину:

США (1) идёт первым
затем Швейцария (41) и так далее.
Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: 1, 41, 44, 49.



        ОДНАКО
  Если ключи не целочисленные, то они перебираются в порядке создания:

        let user = {
          name: "John", 
          surname: "Smith"
        };
        user.age = 25; // Добавим ещё одно свойство 

        // не целочисленные свойства перечислены в порядке создания

        for (let prop in user) {
                alert( prop ); // name, surname, age
        }
















ИТОГО



        Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

Они хранят свойства (пары ключ-значение), где:

Ключи свойств должны быть строками или символами (обычно строками).
Значения могут быть любого типа.
Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: obj.property.
Квадратные скобки obj["property"]. 
Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].




Дополнительные операторы:

Удаление свойства: delete obj.prop.
Проверка существования свойства: "key" in obj.
Перебор свойств объекта: цикл for for (let key in obj).
То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object. 




В JavaScript есть много других типов объектов:

Array для хранения упорядоченных коллекций данных,
Date для хранения информации о дате и времени,
Error для хранения информации об ошибке.
… и так далее.
У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.

</body>
</html>