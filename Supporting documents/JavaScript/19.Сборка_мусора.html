<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>19</title>
</head>
<body>
    

СБОРКА МУСОРА


Всё мною созданное (примитивы, объекты, функции и тд) занимает памать. 

Однако как джс понимает, что что-то больше не нужно и надо очистить память?




ДОСТИЖИМОСТЬ

Основной концепцией управления памятью - принцип достижимости 

Если упростить то "достижимые" значения - те, которые ДОСТУПНЫ ИЛИ ИСПОЛЬЗУЮТСЯ. Они гарантированно находятся в памяти


1) Существует базовое множество достижимых значений, которые не могут быть удалены:
 
ЭТИ значения будем называть КОРНЯМИ: 

    Выполняемая в данный момент функция, её локальные переменные и параметры. 

    Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры

    Глобальные переменные 


2) Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок 

Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то ЭТОТ считается ДОСТИЖИМЫМ. И те, на которые он ссылается, тоже ДОСИЖИМЫ. 


        // в user находится ссылка на объект
        let user = {
        name: "John"
        };

Здесь стрелка обозначает ссылку на объект. Глобальная переменная user ссылается на объект {name: "John"} (мы будем называть его просто «John» для краткости). В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.

    Если перезаписать значение user, то ссылка потеряется:


        user = null;


Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.


_________________________________________________________________________



ДВЕ ССЫЛКИ

Что если мы скопировали ссылку из user в admin: 


        // в user находится ссылка на объект 
        let user = {
            name: "John",
        };

        let admin = user;


    То есть у нас глобальные переменные user и admin ссылаются на один и тот же объект. 
    
    И когда мы сделаем то же самое:


        user = null;   
        
    
    То объект John всё ещё достижим через глобальную переменную admin, поэтому он находится в памяти. Если бы также перезаписали admin, то John был бы удалён. 



_________________________________________________________________________




ВЗАИМОСВЯЗАННЫЕ ОБЪЕКТЫ


Теперь более сложный пример. Семья:


        function marry(man, woman) {
            woman.husband = man;
            man.wife = woman;
        
            return {
                father: man,
                mother: woman,
            }
        }

        let family = marry({name: "John"}, {name: "Ann"});


Функция marry «женит» два объекта, давая им ссылки друг на друга, и возвращает новый объект, содержащий ссылки на два предыдущих.
На данный момент все объекты достижимы.
    Теперь удалим две ссылки:


        delete family.father;
        delete family.mother.husband;

        
Недостаточно удалить только одну из этих двух ссылок, потому что все объекты останутся достижимыми.
    Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок:
    Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, которые также стали недоступны. (стрелка исходит только от объекта name: "John" --wife--> объекту name: "Ann")


После сборки мусора:

        <global>
            |
          family
            |
            |
          OBJECT
            |
            |
          mother
            |
        OBJECT name: "Ann"



_________________________________________________________________________


НЕПОСТИЖИМЫЙ "ОСТРОВ"

Вполне возможна ситуация, при которой целый "остров" взаимосвязанных объектов может стать недостижимым и удалиться из памяти. 

Возьмём объект family из примера выше. А затем:


        family = null;


И тогда весь код отоврётся от глобалки
То есть очень важна концепция достижимости. 

Объекты John и Ann всё ещё связаны, оба имеют входящие ссылки, но это недостаточно. 
Бывший объект family был отсоединён от корня, на него больше нет ссылки, поэтому весь "остров" становится недостижимым и будет удалён. 



_________________________________________________________________________



ВНУТРЕННИЕ АЛГОРИТМЫ


Основной алгоритм сборки мусора называется "алгоритм пометок" (англ. mark-and-sweep). 

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги: 

    .Сборщик мусора "помечает" (запоминает) все корневые объекты. 
    .Затем он идёт по ним и "помечает" все ссылки из них
    .Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды. 
    .И так далее, пока не будут посещены все достижимые (из корней ссылки)
    .Все неотмеченные объекты удаляются 


    
Вот некоторые из оптимизаций:

Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
</body>
</html>