<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24</title>
</head>
<body>
    
    Преобразование объектов в примитивы







    var v1;        // undefined (пустая) локальная переменная
    var v2='2'; // строковая локальная литеральная переменная
    var v3 = new String(2); // строковая локальная, объявленная через конструктор переменная. Создаст новый объект типа String
    v4 = String(2); //строковая глобальная переменная вызванная через конструктор. Создаст переменную window.v4
    '2'.length;        // строка не станет переменной но её можно уже использовать как Объект
    34..toString(); //число не станет переменной но его уже можно использовать как объект
    (22).toString();//число не станет переменной но его уже можно использовать как объект




    Когда вы хотите получить какое-либо свойство или метод для примитивов, вы обращаетесь не к самому примитиву, а к объекту, созданному функцией-конструктором данного примитива. Другими словами, примитивы не имеют свойств и методов и не являются объектами. 







Мы не можем реализовать специальный объектный метод для обработки сложения (или других операторов)

В таких случаях объекты автоматически преобразуются в примитивы, затем выполняется сама операция над этими примитивами, и на выходе получается ПРИМИТИВНОЕ значение

ЭТО ВАЖНОЕ ОГРАНИЧЕНИЕ:
    результатом obj1 + obj2 (или другой оператор) НЕ МОЖЕТ быть другой объект
    
ТО ЕСТЬ
    мы не можем создавать объекты, представляющие векторы или матрицы (или достижения или может ещё что-то), складывать их и ожидать в качестве результата "суммированный" объект. Такие архитектурные ходы автоматически оказываются за бортом. 


    выбрать регион
    исскать на сайте россельхонадхора
    ищем по территориальным направлениям 
рассматриваем управление вцелом
__________________________________________________________________




ПРАВИЛА ПРЕОБРАЗОВАНИЯ 



1) Не существует преобразование к логическому значению. В логическом контексте все объекты являются true. 
Существует лишь их ЧИСЛОВОЕ и СТРОКОВОЕ преобразование.

2) Числовое преобразование происходит, когда мы применяем математические функции. 
    То есть, объекты Date могут быть вычтены, и результатом 
    date1 - date2 будет разница во времени между двумя датами. 

3) Преобразования к строке - обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах 


Также можно преобразовать к строкам и числам, используя специальные объектные методы. 
__________________________________________________________________





ХИНТЫ


Существует три варианта преобразования типов, которые происходят в различных ситуациях. Это и есть хинты. 

1) "string"
Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert: 

        // вывод
        alert(obj);

        // используем объект в качестве ключа 
        anotherObj[obj] = 123;


2) "number"
Для преобразования объекта к числу, в случае математических операций:

    // явное преобразование 
        let num = Number(obj);


    // математические (не считая бинарного плюса)
        let n = +obj; // унарный плюс
        let delta = date1 - date2;


    // сравнение больше/меньше
        let greater = user1 > user2;


Большинство встроенных математических функций также включают в себя такое преобразование: 
        "default"
    ОН ПРОИСХОДИТ редко, когда оператор "не уверен", какой тип ожидать 

ТО ЕСТЬ
    Бинарный плюс + может работать как со строками, так и с числами
Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для преобразования. 

! Если объект сравнивается с помощью == со строкой, числом или символом - такая же ситуация - используется хинт "default"

    // бинарный плюс использует хинт "default"
        let total = obj1 + obj2;

    // obj == number использует хинт "default"
        if (user == 1) { ... };


Операторы < > могут работать как со строками, так и с числами, ОДНАКО, они ипсользуют хинт "number", а не "default"




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Все встроенные объекты, за исключением одного (объект Date), реализуют "default" преобразование тем же способом, что и "number"
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



Чтобы выполнить преобразование, JS пытается найти и вызвать три следующих метода объекта:


    1) Вызвать:

            obj[Symbol.toPrimitive](hint) 
    
    - метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует. 



    2) Иначе, если хинт равен "string"

        - попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует. 



    3) Иначе, если хинт равен "number" или "default"

        - попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует 
__________________________________________________________________






Symbol.toPrimitive 




Первый метод
Есть встроенный символ с именем Symbol.toPrimitive, который следует использовать для обозначения метода преобразования:

    obj[Symbol.toPrimitive] = function(hint) {
        //вот код для преобразования этого объекта в примитивами
        //он должен вернуть примитивное значение 
        //hint = чему-то из "string", "number", "default"
    };

Если метод Symbol.toPrimitive существует, он используется для ВСЕХ ХИНТОВ, и больше никаких методов не трубуется. 

Например: 


        let user = {
            name: "John",
            money: 1000,

            [Symbol.toPrimitive](hint) {
                alert('hint: ${hint}');
                return hint == "string" ? `{name: "${this.name}"}` : this.money;
            }
        };

        alert(user); // hint: string -> {name: "John"}
        alert(+user); // hint: number -> 1000
        alert(user + 500); hint: default -> 1500


    Тут user становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. 
    Единый метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования
__________________________________________________________________





toString/valueOf 


Если нет Symbol.toPrimitive, тогда JS пытается найти методы toString и valueOf: 

    1) Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании)

    2) Для других хинтов: вызвать метод valueOf, а если он не существует или возвращает объект вместо примитивного значения, то toString (таким образом, valueOf имеет приоритет для математических операций)


Методы toString и valueOf это не символы, а скорее обычные методы со строковыми именами. Эти методы должны возращать примитивное значение. Если toString или valueOf возвращает объект, то он игнорирутеся (так же, как если бы метода не было)

По умолчанию обычный объект имеет следующие методы toString и valueOf: 

. Метод toString возвращает строку "[object Object]"
. Метод valueOf возвращает сам объект 


        let user = {name: "John"};

        alert(user); // [object Object]
        alert(user.valueOf() === user); // true 


ТО ЕСТЬ
Если мы попытаемся использовать объект в качестве строки, как например в alert или вроде того, то по умолчанию мы увидим [object Object]

Значение по умолчанию valueOf упоминается здесь только для полноты картины, он возвращает сам объект и поэтому игнорируется. 










</body>
</html>