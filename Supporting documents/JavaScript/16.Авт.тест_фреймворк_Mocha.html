<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16</title>
</head>
<body>
    


    Автоматическое тестирование и использованием фреймворка Mocha



1) Behavior Driven Development (BDD) - разработка, основанная на поведении. 

BDD - три в одном: тесты, документация и примеры использования

    Например, создадим функцию возведения в степень. 
    Перед тем, как начать писать код функции, мы можем представить себе, что она должна делать, и описать её.

Такое ОПИСАНИЕ называется - СПЕЦИФИКАЦИЕЙ

Она содержит описания различных способов использования и тесты для них, например:



    describe("pow", function() {

        it("возводит в степень n", function() {
            assert.equal(pow(2, 3), 8);
        });

    });



Спецификация состоит из трёх основных блоков:

        describe("Заголовок", function() {...})
    Какую функциональность мы описываем. В нашем случае мы описываем функцию pow. Используется для группировки блоков it.


        it("Описание", function() {...})
    В первом аргументе блока it мы человеческим языком описываем конкретный способ использования фунции, а во втором - пишем функцию, которая тестирует данный случай. 


        assert.equal(value1, value2)
    Код внутри блока it, если функция работает верно, должен выполняться без ошибок. 
    Функции вида assert.* используются для проверки того, что функция pow работает так, как мы ожидаем. В этом примере мы используем одну из них - assert.equal, которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу. Существует и другие типы сравнений и проверок, которые мы добавим позже. 

    Спецификация может быть запущена, и при этом будет выполнена проверка, указанная в блоке it.
    
    





Первый шаг уже завершён. У нас есть спецификация для функции pow. Теперь, перед тем, как писать реализацию, нужно подключить библиотеки для пробного запуска тесто, просто чтобы убедиться, что тесты работают (разумеется, они завершаются ошибками)
____________________________________________________




ПРОЦЕСС РАЗРАБОТКИ

Процесс разработки обычно выглядит следующим образом:

1) Пишется начальная спецификация с тестами, проверяющими основную функциональность. 

2) Создаётся начальная реализация 

3) Для запуска тестов мы используем фреймворк Mocha. Пока функция не готова, будут ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нам нужно. 

4) Теперь у нас есть правильно работающая начальная реализация и тесты 

5) Мы добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в тестируемом коде. Тесты начинают "падать" (выдавать ошибки)

6) Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок. 

7) Повторяем шаги 3-6, пока требуемая функциональность не будет готова. 



ТАКИМ ОБРАЗОМ, разработка проходит ИТЕРАТИВНО. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и так далее. 

____________________________________________________
Принципиальная разница в том, что когда один из assert выбрасывает ошибку, то выполнение it блока тут же прекращается. Таким образом, если первый assert выбросит ошибку, результат работы второго assert мы уже не узнаем.

Разделять тесты предпочтительнее, так как мы получаем больше информации о том, что конкретно пошло не так.

Помимо этого есть одно хорошее правило, которому стоит следовать.

Один тест проверяет одну вещь.

Если вы посмотрите на тест и увидите в нём две независимые проверки, то такой тест лучше разделить на два более простых.
____________________________________________________








Вложенные блоки describe



Мы собираемся добавить больше тестов. Однако, перед этим стоит сгруппировать вспомогательную функцию makeTest и цикл for. Нам не нужна функция makeTest в других тестах, она нужна только в цикле for. 
Её предназначение – проверить, что pow правильно возводит число в заданную степень.




    describe("pow", function() {

        describe("Возводит x в степень 3", function() {

            function makeTest(x) {
                let expected = x * x * x;
                it(`${x} в степени 3 будет ${expected}`, function(){
                    assert.equal(pow(x, 3), expected);
                });
            }

            for (let x = 1; x <= 5; x++) {
                makeTest(x);
            }
        });


        //... другие тесты. Можно писать и describe, и it блоки. 
    });
_________________________________________________________________________










before/after и beforeEach/afterEach 


Мы можем задать before/after функции, которые будут выполняться до/после тестов, а также функции beforeEach/afterEach, выполняемые до/после каждого it.


    Наример:
       
    describe("тест", function() {

      before(() => alert("Тестирование началось - перед тестами"));
      after(() => alert("Тестирование закончилось - после всех тестов"));


      beforeEach(() => alert("Перед тестом начинаем выполнять тест"));
      afterEach(() => alert("После теста - заканчиваем выполнение теста"));


      it(`тест 1`, () => alert(1));
      it(`тест 2`, () => alert(2));

    });

    

    Порядок выполнения будет таким:

    Тестирование началось – перед тестами (before)
    Перед тестом – начинаем выполнять тест (beforeEach)
    1
    После теста – заканчиваем выполнение теста (afterEach)
    Перед тестом – начинаем выполнять тест (beforeEach)
    2
    После теста – заканчиваем выполнение теста (afterEach)
    Тестирование закончилось – после всех тестов (after)

_________________________________________________________________________



РАСШИРЕНИЕ СПЕЦИФИКАЦИИ


Например, что если введена неверная n
Для обозначения математических ошибок функции JavaScript обычно возвращает NaN. 

Сначала нужно описать это поведение в спецификации


    describe("pow", function() {
        
        // что там было до этого

        it("для отрицательных n возвращает NaN", function() {
            assert.isNaN(pow(2, -1));
        });

        it("для дробных n возвращает NaN", function() {
            assert.isNaN(pow(2, 1.5));
        });

    });



Вышенаписанные тесты упадут, потому что моя реализация не поддерживает их. Так работает BDD. Сначала мы добавляем тесты, которые падают, а уже потом пишем под них реализацию. 
_________________________________________________________________________












Другие функции сравнения
Обратите внимание на assert.isNaN. Это проверка того, что переданное значение равно NaN.

Библиотека Chai содержит множество других подобных функций, например:

1) assert.equal(value1, value2) – проверяет равенство value1 == value2.

2) assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.

3) assert.notEqual, assert.notStrictEqual – проверяет неравенство и строгое неравенство соответственно.

4) assert.isTrue(value) – проверяет, что value === true

5) assert.isFalse(value) – проверяет, что value === false


















    







</body>
</html>