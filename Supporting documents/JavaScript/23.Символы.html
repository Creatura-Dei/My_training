<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>23</title>
</head>
<body>
    
    Тип данных Symbol


Символ - уникальный идентификатор. Создаётся с помощью функции Symbol();




Символы не преобразуются автоматически в строки


Для этого используем метод toString
        let id = Symbol("id");
        alert(id.toString()); // Symbol(id), теперь работает


Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

        let id = Symbol("id");
        alert(id.description); // id
______________________________________________________________________




"СКРЫТЫЕ" СВОЙСТВА

Символы позволяют создавать скрытые свойства объектов, к которым нельзя случайно обратиться и перезаписать их из других частей программы


        let user = {
            name: "John"
        };

        let id = Symbol("id");

        user[id] = 1;

        alert( user[id] ); // 1


Однако лучше использовать символ Symbol("id"), а не строку "id"

Сторонний код может создать для этого свой символ Symbol("id")


        let id = Symbol("id");

        user[id] = "Их идентификатор";


Конфликта между ними их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают. 

НО 

Если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:


        let user = {name: "Вася"};

            // Объявление в скрипте свойства "id"

        user.id = "Наш идентификатор";

            // ...другой скрипт тоже хочет свой идентификатор
        
        user.id = "Их идентификатор"

            // СВОЙСТВО ПЕРЕЗАПИСАНО СТОРОННЕЙ БИБЛИОТЕКОЙ 
______________________________________________________________________



СИМВОЛЫ В ЛИТЕРАЛЬНОМ ОБЪЕКТЕ

Символ в объекте заключают в квадаратные скобки 


        let id = Symbol("id");

        let user = {
            name: "Вася",
            [id]: 123 // просто id: 123 не сработает
        };


______________________________________________________________________





СИМВОЛЫ ИГНОРИРУЮТСЯ ЦИКЛОМ for...in 

Свойства, чьи ключи - символы, не перебираются циклом for...in 


        let id = Symbol("id");
        let user = {
            name: "Вася",
            age: 30,
            [id]: 123,
        };

        for (let key in user) alert(key); // name, age 

Хотя прямой доступ к символу работает:

        alert( "Напрямую: " + user.[id] );




ОДНАКО 

    Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:


        let id = Symbol("id");
        let user = {
            [id]: 123,
        };

        let clone = Object.assign({}, user);

        alert( clone[id] ); // 123


______________________________________________________________________



ГЛОБАЛЬНЫЕ СИМВОЛЫ


Иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов:

    Symbol.for(key)
         
Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе создаётся новый символ Symbol(key) и записывается в реестр под ключом key. 


            // читаем символ из глобального реестра и записываем его в переменную
        let id = Symbol.for("id"); // если символа не существует, он будет создан 

            // читаем снова и записываем другую переменную (возможно, из другого места кода)
        let idAgain = Symbol.for("id");

            // проверяем -- это один и тот же символ
        alert( id === idAgain ); // true 


Символы, содержащиеся в реестре, называются ГЛОБАЛЬНЫМИ СИМВОЛАМИ. 

______________________________________________________________________



Symbol.keyFor 



Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя. 


            // получаем символ по имени
        let sym = Symbol.for("name");
        let sym2 = Symbol.for("id");

            // получаем имя по символу
        alert( Symbol.keyFor(sym) ); // name
        alert( Symbol.keyFor(sym2) ); // id  


Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.


ОДНАКО 


Для любых символов доступно свойство description 


        let globalSymbol = Symbol.for("name");
        let localSymbol = Symbol("name");

        alert( Symbol.keyFor(globalSymbol) ); // name, глобальный 
        alert( Symbol.keyFor(localSymbol) ); // undefined не глобальны

        alert( localSymbol.description ); name
______________________________________________________________________




СИСТЕМНЫЕ СИМВОЛЫ


Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.


    Symbol.hasInstance
    Symbol.isConcatSpreadable
    Symbol.iterator
    Symbol.toPrimitive
    …и так далее.
______________________________________________________________________




ПОИСК СИМВОЛЬНЫХ СВОЙСТВ У ОБЪЕКТОВ 


Метод Object.getOwnPropertySymbol();
Возвращает массив символов и позволяет получить символьные свойства объекта. 
Важно, что при инициализации объекты не получают символьных свойств, так что этот массив будет пуст, пока Я НЕ ЗАДАМ ему какое-либо символьное свойство. 




</body>
</html>