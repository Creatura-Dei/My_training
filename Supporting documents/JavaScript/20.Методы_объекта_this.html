<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20</title>
</head>
<body>
    



    Методы объекта, "this"



Когда пользователь что-то добавляет в корзину, авторизовывается, оплачивает - такие действия представлены ФУНКЦИЯМИ в СВОЙСТВАХ ОБЪЕКТА

    Пример:


        let user = {
            name: "John",
            age: 30,
        };

        user.sayHi = function() {
            alert("Привет!");
        };

        user.sayHi(); // Привет!



Функцию, которая является свойством объекта, называют методом этого объекта.

То есть, я получил метод sayHi объекта user


Однако можно было бы сделать и так:

        let user = {
            // ...
        };
        
        // сначала, объявляем
        function sayHi() {
            alert("Привет!");
        }
        
        // затем добавляем в качестве метода
        user.sayHi = sayHi;
        
        user.sayHi(); // Привет!



Более короткий синтаксис для методов в литерале объекта:


// эти объекты делают одно и то же


        user = {
            sayHi: function() {
                alert("Привет");
            }
        };


// сокращённая запись предпочтительнее 

        user = {
            sayHi() {
                alert("Привет");
            }
        };




_____________________________________________________



КЛЮЧЕВОЕ СЛОВО "this" В МЕТОДАХ



Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы

Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в объекте user. 

    Для доступа к информации внутри объекта метод может использовать слово "this"

Значение this - объект "перед точкой", который используется для вызова метода. 

    Например:
    
        let user = {
            name: "John",
            age: 30,

            sayHi() {
                //this - это текущий объект
                alert(this.name);
            }

        };

        user.sayHi(); // John


Но также можно обратиться не через this, а через внешнюю переменную (в которой хранится ссылка на этот объект)


        let user = {
            name: "John",
            age: 30,

            sayHi() {
                alert(user.name); // "user" вместо "this"
            
            }
        };


НО такой код ненадёжен. Так как при копировании ссылки на объект user в другую переменную (admin = user), и перезапишем переменную user - обращаться будем к несуществующей 


__________________________________________________________________________



"this" не является фиксированным 


Его можно использовать в любой функции, даже если это не метод объекта. 


        function sayHi() {
            alert( this.name );
        }


Значение this вычисляется во время выполнения кода, в зависимости от контекста. 

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение "this" в вызовах: 

        let user = { name: "John" };
        let admin = { name: "Admin" };

        function sayHi() {
            alert( this. name );
        }

    

             // используем одну и ту же функцию в двух объектах
        user.f = sayHi;
        admin.f = sayHi;
        
            // эти вызовы имеют  разное значение this
            // "this" внутри функции - это объект "перед точкой"
        user.f(); // John  (this == user)
        admin.f(); // Admin  (this == admin)
        
        admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)        
        
        
_____________________________________________________


Вызов без объекта: this == undefined 


        function sayHi() {
            alert(this);
        }

        sayHi(); //undefined 

В строгом режиме - undefined
В нестрогом - значением this будет глобальный объект (window в браузере)



! ТО ЕСТЬ
    Подобный вызов является ошибкой программирования. Если внутри функции используется this, тогда она ожидает, что будет вызвана в контексте какого-либо объекта

__________________________________________________________________________



У СТРЕЛОЧНЫХ ФУНКЦИЙ НЕТ "THIS"


У стрелочных функций нет своего "собственного" this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней "нормальной функции" 

  Например, здесь arrow() использует this из внешнего метода user.sayHi():
        
        let user = {
            firstName: "Ilya",

            sayHi() {
                let arrow = () => alert(this.firstName);
                arrow();
            }

        };

        user.sayHi(); // Ilya



</body>
</html>