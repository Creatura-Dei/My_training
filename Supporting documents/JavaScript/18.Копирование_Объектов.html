<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>18</title>
</head>
<body>
    


Копирование объектов и ссылки

Одно из главных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются "по ссылке", тогда как примитивные значения: строки, числа, логический значения и т.д. - всегда копируются "как целое значение"

Например:

    let message = "Привет!";
    let phrase = message;

То есть мы имеем две независимые переменные, каждая из которых хранит строку "Привет!"


ОБЪЕКТЫ ВЕДУТ СЕБЯ ИНАЧЕ:

    Переменная, которой присвоен объект, хранит не сам объект, а его "адрес в памяти" - ТО ЕСТЬ "ссылку" на него.

let user = {
    name: "John";
};




ТАК ВОТ В ЧЁМ СОЛЬ

ПРИ КОПИРОВАНИИ ПЕРЕМЕННОЙ ОБЪЕКТА КОПИРУЕТСЯ ССЫЛКА, НО САМ ОБЪЕКТ НЕ ДУБЛИРУЕТСЯ


    let user = { name: "John" };
    let admin = user; // копируется ссылка 


Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект. 
Отсюда, мы можем использовать любую переменную для доступа к объекту и изменениям его содержимого: 

    let user = { name: "John" };
    let admin = user; 
    admin.name = "Pete"; // изменено по ссылке из переменной "admin"

    alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user" 

ШКАВЧИК - ДВА КЛЮЧА


_________________________________________________________________________








СРАВНЕНИЕ ПО  ССЫЛКЕ




Два объекта равны только в том случае, если это один и тот же объект. 


Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:


        let a = {};
        let b = a; // копирование по ссылке

        alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
        alert( a === b ); // true



_________________________________________________________________________




КОПИРОВАНИЕ ОБЪЕКТА


Можно тупо в лоб скопировать все свойства объекта 1 в объект 2


        let user = {
            name: "John",
            age: 30,
        };

        let clone - {};

            // теперь копируем все свойства user в clone

        for (let key in user) {
            clone[key] = user[key];
        }

            // теперь clone независимый объект с копией свойств user

        clone.name = "Pete"; //меняем данные 
        alert( user.name ); //всё ещё John, его не тронули






ОДНАКО ТАКЖЕ МЫ МОЖЕМ ИСПЛЬЗОВАТЬ МЕТОД 

            Object.assign(dest, [src1, src2, src3 ...])



dest - первый аргумент - целевой объект

остальные аргументы - может быть сколько угодно - являются исходными объектами

метод копирует свойства всех исходных src1, src2 ... в целевой объект dest.


    Например, можно объединить несколько объектов в один:

        let user = { name: "John" };

        let permissions1 = { canView: true };
        let permissions2 = { canEdit: true };

            // копируем все свойства из permissions1 и 2 ПРЯМИКОМ в user 

        Object.assign(user, permissions1, permissions2);

            // теперь user = { name: "John", canView: true, canEdit: true }


Если скопированное имя свойства уже существует, оно будет перезаписано:

        let user = { name: "John" };

        Object.assign(user, { name: "Pete" });

        alert(user.name); // теперь user = { name: "Pete" }






+ ТАКЖЕ МОЖНО использовать Object.assign для замены цикла for..in для простого клонирования 


        let user = {
            name: "John",
            age: 30,
        };

        let clone = Object.assign({}, user);

Он копирует все свойства user в пустой объект и возвращает его.




_________________________________________________________________________






ВЛОЖЕННОЕ КЛОНИРОВАНИЕ



Ранее мы предполагали, что все свойства user примитивные. Но свойства могут быть и ссылками на другие объекты. 

    Например:

        let user = {
            name: "John",
            sizes: {
                height: 182,
                width: 50,
            };
        };

    alert( user.sizes.height ); // 182


НО 

Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes - ЭТО ОБЪЕКТ и ОН СКОПИРУЕТСЯ ТОЛЬКО ССЫЛКОЙ. 
ТО ЕСТЬ clone и user будут иметь общий объект sizes: 


         let user = {
            name: "John",
            sizes: {
                height: 182,
                width: 50,
            };
        };

        let clone = Object.assign({}, user);

        alert( user.sizes === clone.sizes ); //true, тот же объект

            //  user и clone обладают общим свойством sizes, а так НЕ должно быть 

        user.sizes.width++; // изменяем свойства в первом объекте
        alert(clone.sizes.width); // 51, видим результат в другом


ГЛУБОКОЕ КЛОНИРОВАНИЕ --- исправляет это. 
Нужно использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект - ТОГДА также копирует его структуру. 
 
Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.


Также мы можем использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами


_________________________________________________________________________




Глубокое клонирование пример:


        let user = {
            name: "John",
            age: 30,

            param = {
                weight: 70,
                height: 180,

                type = {
                    character: "loud",
                }
            }
        };

        

        function cloneObject(obj) {
            let clone = {};

            for (let key in obj) {
                 if (typeof obj[key] == 'object') {
                    clone[key] = cloneObject(obj[key]);
                 } else {
                    clone[key] = obj[key];
                 }
            }
            
        return clone;
        }

</body>
</html>